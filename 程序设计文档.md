
## 架构概览
- **Model 层**
  - `CardModel`：单张牌状态（点数、花色、正反、所在区域、是否栈顶、世界坐标）。支持序列化/反序列化。
  - `GameModel`：整局状态（牌列表、当前栈顶 ID、备用堆基准坐标）。支持序列化/反序列化。
- **View 层**
  - `CardView`：渲染单牌，绘制点数/花色，处理点击并上报回调。
  - `GameView`：布局牌区与备用堆容器，生成卡牌视图，播放移动与撤销动画，转发点击与撤销按钮事件。
- **Controller 层**
  - `GameController`：装配模型/视图，加载关卡生成模型，绑定回调；处理牌区/备用堆点击规则、更新模型、记录撤销、触发动画。
- **工具**
  - `CardTextureHelper`：提供牌面纹理名。

## 关键流程
- **初始化**
  - `startGame` → `initGameModel`（关卡加载、模型生成、撤销管理器）→ `initGameView`（以模型快照生成视图）→ 绑定回调。
- **点击与规则**
  - 牌区牌点击：规则检查（点数差 1），更新模型位置/栈顶标记，压入撤销记录，播放移动到栈顶动画。
  - 备用堆非栈顶点击：与栈顶交换位置和标记，压入撤销记录，播放覆盖动画。
- **撤销**
  - 从撤销栈弹出记录，按快照还原模型（含栈顶 ID），调用 `playUndoMoveAnimation` 回放，支持跨容器重挂保持 y 基线。

## 新增一张卡牌（按当前结构）
1. 在关卡加载/生成时向 `GameModel::cards` push 一条新的 `CardModel`，填好 `cardId`、`faceType`、`suitType`、区域标志、栈顶标记、`position`；若为栈顶，更新 `currentStackTopCardId`。
2. 调用 `GameView::refreshAllCards()`（或现有刷新路径）以生成对应 `CardView` 并放入正确容器。
3. 规则与点击无需额外接线；若有新规则逻辑，扩展 `GameController` 对应处理。
4. 存档/读档已支持；若新增字段需同步更新 `toValueMap/fromValueMap`。
